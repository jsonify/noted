/**
 * Auto-tagging service for extracting tags from AI summaries and applying them to notes
 * Phase 4 of AI Summarization implementation
 */

import { readFile, writeFile } from './fileSystemService';
import { parseFrontmatter, hasFrontmatter } from '../utils/frontmatterParser';
import { isValidTag, normalizeTag, formatTagForDisplay } from '../utils/tagHelpers';

/**
 * Mode for applying tags to notes
 */
export type TagApplicationMode = 'append' | 'replace' | 'suggest';

/**
 * Result of tag extraction from summary
 */
export interface ExtractedTags {
    tags: string[];
    rawKeywords: string[];
}

/**
 * Result of tag application operation
 */
export interface TagApplicationResult {
    success: boolean;
    addedTags: string[];
    removedTags: string[];
    finalTags: string[];
    error?: string;
}

/**
 * Tag suggestion for preview
 */
export interface TagSuggestion {
    filePath: string;
    currentTags: string[];
    suggestedTags: string[];
    mergedTags: string[];
}

/**
 * Generic words to filter out from auto-generated tags
 * These are too common to be useful as tags
 */
const GENERIC_WORDS = new Set([
    'note', 'notes', 'summary', 'content', 'file', 'document',
    'text', 'information', 'data', 'item', 'items', 'thing', 'things',
    'stuff', 'general', 'misc', 'miscellaneous', 'other', 'various',
    'todo', 'task', 'work', 'project', // These might be kept if hierarchical
]);

/**
 * Service for auto-tagging notes based on AI summary analysis
 */
export class AutoTagService {
    constructor() {}

    /**
     * Extract tags from a summary text
     * Looks for keywords section with hashtags (generated by summarization)
     *
     * @param summary The AI-generated summary text
     * @returns Extracted tags and raw keywords
     */
    extractTagsFromSummary(summary: string): ExtractedTags {
        const tags: string[] = [];
        const rawKeywords: string[] = [];

        // Look for keywords/tags section in the summary
        // The summarization prompt asks AI to generate keywords with # format
        const keywordPatterns = [
            /(?:keywords?|tags?):\s*([^\n]+)/gi,
            /(?:##\s*keywords?|##\s*tags?)\s*\n([^\n#]+)/gi,
            /\*\*(?:keywords?|tags?):\*\*\s*([^\n]+)/gi
        ];

        for (const pattern of keywordPatterns) {
            pattern.lastIndex = 0; // Reset regex
            let match;
            while ((match = pattern.exec(summary)) !== null) {
                const keywordsLine = match[1].trim();
                rawKeywords.push(keywordsLine);

                // Extract hashtags from the keywords line
                const hashtagPattern = /#([a-z0-9]+(?:-[a-z0-9]+)*)(?:\/[a-z0-9]+(?:-[a-z0-9]+)*)*/gi;
                let tagMatch;
                hashtagPattern.lastIndex = 0;

                while ((tagMatch = hashtagPattern.exec(keywordsLine)) !== null) {
                    const tag = normalizeTag(tagMatch[1]);
                    if (tag && this.isUsefulTag(tag)) {
                        tags.push(tag);
                    }
                }
            }
        }

        // Remove duplicates
        const uniqueTags = Array.from(new Set(tags));

        return {
            tags: uniqueTags,
            rawKeywords
        };
    }

    /**
     * Check if a tag is useful (not generic/common)
     *
     * @param tag The tag to validate
     * @returns true if tag is useful
     */
    private isUsefulTag(tag: string): boolean {
        if (!isValidTag(tag)) {
            return false;
        }

        // Check for hierarchical tags (these are usually specific enough)
        if (tag.includes('/')) {
            return true;
        }

        // Filter out generic words
        const normalizedTag = tag.toLowerCase();
        if (GENERIC_WORDS.has(normalizedTag)) {
            return false;
        }

        // Filter out single character tags
        if (tag.length <= 1) {
            return false;
        }

        return true;
    }

    /**
     * Get current tags from a note file
     *
     * @param filePath Path to the note file
     * @returns Array of current tags
     */
    async getCurrentTags(filePath: string): Promise<string[]> {
        try {
            const content = await readFile(filePath);
            const frontmatter = parseFrontmatter(content);
            return frontmatter.tags || [];
        } catch (error) {
            console.error(`[NOTED] Error reading tags from ${filePath}:`, error);
            return [];
        }
    }

    /**
     * Merge current tags with suggested tags (no duplicates)
     *
     * @param currentTags Current tags in the note
     * @param suggestedTags Tags extracted from summary
     * @returns Merged array of unique tags
     */
    mergeTags(currentTags: string[], suggestedTags: string[]): string[] {
        const allTags = new Set<string>();

        // Add current tags
        currentTags.forEach(tag => allTags.add(normalizeTag(tag)));

        // Add suggested tags
        suggestedTags.forEach(tag => allTags.add(normalizeTag(tag)));

        // Sort alphabetically for consistency
        return Array.from(allTags).sort();
    }

    /**
     * Update frontmatter in note content with new tags
     * Creates frontmatter if it doesn't exist
     *
     * @param content The note content
     * @param tags Tags to set in frontmatter
     * @returns Updated content with new frontmatter
     */
    updateFrontmatterTags(content: string, tags: string[]): string {
        const normalizedTags = tags.map(tag => normalizeTag(tag));
        const tagLine = `tags: [${normalizedTags.join(', ')}]`;

        if (hasFrontmatter(content)) {
            // Update existing frontmatter
            const lines = content.split('\n');
            let frontmatterEnd = -1;
            let tagsLineIndex = -1;
            let inFrontmatter = false;

            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();

                if (line === '---') {
                    if (!inFrontmatter) {
                        inFrontmatter = true;
                    } else {
                        frontmatterEnd = i;
                        break;
                    }
                } else if (inFrontmatter && line.startsWith('tags:')) {
                    tagsLineIndex = i;
                }
            }

            if (frontmatterEnd === -1) {
                // Malformed frontmatter, just prepend new one
                return this.prependFrontmatter(content, tags);
            }

            if (tagsLineIndex !== -1) {
                // Replace existing tags line
                lines[tagsLineIndex] = tagLine;
            } else {
                // Insert tags line before closing ---
                lines.splice(frontmatterEnd, 0, tagLine);
            }

            return lines.join('\n');
        } else {
            // Create new frontmatter
            return this.prependFrontmatter(content, tags);
        }
    }

    /**
     * Prepend frontmatter with tags to content
     *
     * @param content The note content
     * @param tags Tags to include
     * @returns Content with frontmatter prepended
     */
    private prependFrontmatter(content: string, tags: string[]): string {
        const normalizedTags = tags.map(tag => normalizeTag(tag));
        const frontmatter = `---\ntags: [${normalizedTags.join(', ')}]\n---\n\n`;
        return frontmatter + content;
    }

    /**
     * Apply tags to a note file
     *
     * @param filePath Path to the note file
     * @param tags Tags to apply
     * @param mode Application mode (append, replace, suggest)
     * @returns Result of the operation
     */
    async applyTags(
        filePath: string,
        tags: string[],
        mode: TagApplicationMode = 'append'
    ): Promise<TagApplicationResult> {
        try {
            const content = await readFile(filePath);
            const currentTags = await this.getCurrentTags(filePath);

            let finalTags: string[];
            let addedTags: string[];
            let removedTags: string[] = [];

            switch (mode) {
                case 'replace':
                    finalTags = tags.map(tag => normalizeTag(tag));
                    addedTags = finalTags.filter(tag => !currentTags.includes(tag));
                    removedTags = currentTags.filter(tag => !finalTags.includes(tag));
                    break;

                case 'append':
                    finalTags = this.mergeTags(currentTags, tags);
                    addedTags = finalTags.filter(tag => !currentTags.includes(tag));
                    break;

                case 'suggest':
                    // For suggest mode, don't actually modify the file
                    finalTags = this.mergeTags(currentTags, tags);
                    addedTags = finalTags.filter(tag => !currentTags.includes(tag));
                    return {
                        success: true,
                        addedTags,
                        removedTags: [],
                        finalTags
                    };

                default:
                    return {
                        success: false,
                        addedTags: [],
                        removedTags: [],
                        finalTags: currentTags,
                        error: `Unknown mode: ${mode}`
                    };
            }

            // Update the file
            const updatedContent = this.updateFrontmatterTags(content, finalTags);
            await writeFile(filePath, updatedContent);

            return {
                success: true,
                addedTags,
                removedTags,
                finalTags
            };

        } catch (error) {
            return {
                success: false,
                addedTags: [],
                removedTags: [],
                finalTags: [],
                error: error instanceof Error ? error.message : String(error)
            };
        }
    }

    /**
     * Generate tag suggestions for a note without applying them
     *
     * @param filePath Path to the note file
     * @param summary AI-generated summary
     * @returns Tag suggestion with current and suggested tags
     */
    async suggestTags(filePath: string, summary: string): Promise<TagSuggestion> {
        const currentTags = await this.getCurrentTags(filePath);
        const extracted = this.extractTagsFromSummary(summary);
        const mergedTags = this.mergeTags(currentTags, extracted.tags);

        return {
            filePath,
            currentTags,
            suggestedTags: extracted.tags,
            mergedTags
        };
    }

    /**
     * Format tag suggestion for display
     *
     * @param suggestion Tag suggestion to format
     * @returns Formatted string for display
     */
    formatSuggestionForDisplay(suggestion: TagSuggestion): string {
        const currentDisplay = suggestion.currentTags.length > 0
            ? suggestion.currentTags.map(formatTagForDisplay).join(', ')
            : '(none)';

        const suggestedDisplay = suggestion.suggestedTags.length > 0
            ? suggestion.suggestedTags.map(formatTagForDisplay).join(', ')
            : '(none)';

        const newTagsDisplay = suggestion.suggestedTags
            .filter(tag => !suggestion.currentTags.includes(tag))
            .map(formatTagForDisplay)
            .join(', ') || '(none)';

        return `Current tags: ${currentDisplay}\nSuggested tags: ${suggestedDisplay}\nNew tags to add: ${newTagsDisplay}`;
    }
}
